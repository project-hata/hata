
module Verification.Core.Data.Expr.Variant.Base.Instance.Monad where

open import Verification.Conventions hiding (‚Ñï)

open import Verification.Core.Setoid.Definition
open import Verification.Core.Setoid.Instance.Category
open import Verification.Core.Data.AllOf.Product
open import Verification.Core.Data.AllOf.Sum
open import Verification.Core.Data.Expr.Variant.Base.Definition
open import Verification.Core.Data.Universe.Definition
open import Verification.Core.Data.Universe.Instance.Category
open import Verification.Core.Category.Std.Category.Definition
open import Verification.Core.Category.Std.Category.Opposite
open import Verification.Core.Category.Std.Category.Construction.Product
open import Verification.Core.Category.Std.Category.Instance.FiniteProductCategory
open import Verification.Core.Category.Std.Limit.Specific.Product
open import Verification.Core.Category.Std.Limit.Specific.Product.Instance.Functor
open import Verification.Core.Category.Std.Functor.Definition
open import Verification.Core.Category.Std.Functor.Constant
open import Verification.Core.Setoid.As.Category
open import Verification.Core.Setoid.Discrete
open import Verification.Core.Setoid.Definition

open import Verification.Core.Category.Std.Monad.Definition
open import Verification.Core.Category.Std.Monad.Instance.Category
open import Verification.Core.Category.Std.Monad.Instance.LargeCategory
open import Verification.Core.Theory.Std.Inference.Definition
open import Verification.Core.Theory.Std.Inference.TextInfer

{-

module _ {A : ùí∞ ùëñ} {a b : A} where
  instance
    isSetoid:‚â£ : isSetoid (a ‚â£ b)
    isSetoid:‚â£ = isSetoid:byDiscrete

instance
  isSetoid:BaseExprData : isSetoid BaseExprData
  isSetoid:BaseExprData = isSetoid:byDiscrete

  isCategory:BaseExprData : isCategory BaseExprData
  isCategory:BaseExprData = isCategory:bySetoid

module _ {P : BaseExprData} where
  mutual
    map-BaseExprs : ‚àÄ{A B} -> (A -> B) -> Vec (BaseExpr P A) n -> Vec (BaseExpr P B) n
    map-BaseExprs f [] = []
    map-BaseExprs f (x ‚à∑ xs) = map-BaseExpr f x ‚à∑ map-BaseExprs f xs

    map-BaseExpr : ‚àÄ{A B} -> (A -> B) -> BaseExpr P A -> BaseExpr P B
    map-BaseExpr f (hole x) = hole (f x)
    map-BaseExpr f (var x) = var x
    map-BaseExpr f (token x) = token x
    map-BaseExpr f (list x) = list (map-BaseExprs f x)
    map-BaseExpr f (annotation x expr) = map-BaseExpr f expr

  instance
    isFunctor:BaseExpr : isFunctor (ùêîùêßùê¢ùêØ ‚Ñì‚ÇÄ) (ùêîùêßùê¢ùêØ ‚Ñì‚ÇÄ) (BaseExpr P)
    isFunctor.map isFunctor:BaseExpr = map-BaseExpr
    isFunctor.isSetoidHom:map isFunctor:BaseExpr = {!!}
    isFunctor.functoriality-id isFunctor:BaseExpr = {!!}
    isFunctor.functoriality-‚óÜ isFunctor:BaseExpr = {!!}

  pure-BaseExpr : ‚àÄ(A) -> A -> BaseExpr P A
  pure-BaseExpr _ = hole

  mutual
    join-BaseExprs : ‚àÄ(A) -> Vec (BaseExpr P (BaseExpr P A)) n -> Vec (BaseExpr P A) n
    join-BaseExprs _ [] = []
    join-BaseExprs _ (x ‚à∑ xs) = join-BaseExpr _ x ‚à∑ join-BaseExprs _ xs

    join-BaseExpr : ‚àÄ(A) -> BaseExpr P (BaseExpr P A) -> BaseExpr P A
    join-BaseExpr _ (hole expr) = expr
    join-BaseExpr _ (var x) = var x
    join-BaseExpr _ (token x) = token x
    join-BaseExpr _ (list x) = list (join-BaseExprs _ x)
    join-BaseExpr _ (annotation x expr) = join-BaseExpr _ expr

  instance
    isMonad:BaseExpr : isMonad (BaseExpr P)
    isMonad.pure isMonad:BaseExpr = pure-BaseExpr
    isMonad.join isMonad:BaseExpr = join-BaseExpr
    isMonad.isNatural:pure isMonad:BaseExpr = {!!}
    isMonad.isNatural:join isMonad:BaseExpr = {!!}
    isMonad.unit-l-join isMonad:BaseExpr = {!!}
    isMonad.unit-r-join isMonad:BaseExpr = {!!}
    isMonad.assoc-join isMonad:BaseExpr = {!!}

  -- instance
  --   hasTextInfer:BaseExpr : hasTextInfer (BaseExpr P)
  --   hasTextInfer.TIObj hasTextInfer:BaseExpr = ‚ä§-ùí∞
  --   hasTextInfer.parse hasTextInfer:BaseExpr = parseBaseExpr
  --   hasTextInfer.IShow:TI hasTextInfer:BaseExpr = it



-------------------------
-- Building a monad from a parametrized monad

open import Verification.Core.Setoid.Definition
open import Verification.Core.Category.Std.Category.Instance.Category
open import Verification.Core.Category.Std.Fibration.GrothendieckConstruction.Op.Definition
open import Verification.Core.Category.Std.Category.Subcategory.Definition
open import Verification.Core.Category.Std.Functor.Instance.Category
open import Verification.Core.Category.Std.Natural.Definition
open import Verification.Core.Category.Std.Natural.Instance.Setoid
open import Verification.Core.Category.Std.Morphism.Iso


module _ {ùíû : Category ùëñ} {ùíü : Category ùëó} where
  infixl 200 _‚áÇ_ _‚áÇ‚âÄ_
  _‚áÇ_ : (F : Functor ùíû ùíü) -> ‚àÄ{a b : ‚ü® ùíû ‚ü©} -> (f : a ‚ü∂ b) -> ‚ü® F ‚ü© a ‚ü∂ ‚ü® F ‚ü© b
  _‚áÇ_ F f = map f

  _‚áÇ‚âÄ_ : (F : Functor ùíû ùíü) -> ‚àÄ{a b : ‚ü® ùíû ‚ü©} -> {f‚ÇÄ f‚ÇÅ : a ‚ü∂ b}
        -> f‚ÇÄ ‚àº f‚ÇÅ -> F ‚áÇ f‚ÇÄ ‚àº F ‚áÇ f‚ÇÅ
  _‚áÇ‚âÄ_ F p = cong-‚àº p


{-
module _ {ùíû : Category ùëñ} {ùí´ : Category ùëó} (T : Functor ùí´ (ùêåùêßùêù ùíû)) where
  private
    F : Functor (ùí´ ·µí·µñ) (ùêÇùêöùê≠ _)
    F = Const ùíû

    ‚Ñ∞ : Category _
    ‚Ñ∞ = ùí´ √ó-ùêÇùêöùê≠ ùíû


    S·µò : ‚ü® ‚Ñ∞ ‚ü© -> ‚ü® ‚Ñ∞ ‚ü©
    S·µò (a , x) = a , (‚ü® ‚ü® T ‚ü© a ‚ü© x)

    macro S = #structureOn S·µò

    map-S : ‚àÄ{a b} -> a ‚ü∂ b -> S a ‚ü∂ S b
    map-S {a , a‚É®} {b , b‚É®} (f , f‚É®) = f , ((‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ f‚É®) ‚óÜ ‚ü® ‚ü® T ‚áÇ f ‚ü© ‚ü© b‚É®

    instance
      isSetoidHom:map-S : ‚àÄ{a} {b} -> isSetoidHom (a ‚ü∂ b) (S a ‚ü∂ S b) (map-S)
      isSetoidHom.cong-‚àº (isSetoidHom:map-S {a , a‚É®} {b , b‚É®}) {f , f‚É®} {g , g‚É®} (p , p‚É®) = p , q
        where
          q : (‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ f‚É® ‚óÜ ‚ü® ‚ü® T ‚áÇ f ‚ü© ‚ü© b‚É®
              ‚àº
              (‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ g‚É® ‚óÜ ‚ü® ‚ü® T ‚áÇ g ‚ü© ‚ü© b‚É®
          q = ((‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ‚âÄ p‚É®) ‚óà ‚ü® ‚ü® T ‚áÇ‚âÄ p ‚ü© ‚ü© b‚É®

    functoriality-id-S : ‚àÄ{a} -> map-S (idOn a) ‚àº idOn (S a)
    functoriality-id-S {a , a‚É®} = refl , (functoriality-id {{of ‚Ü≥ ‚ü® T ‚ü© a}} ‚óà ‚ü® ‚ü® functoriality-id ‚ü© ‚ü© a‚É® ‚àô unit-2-‚óÜ)

    functoriality-‚óÜ-S : ‚àÄ{a b c : ‚ü® ‚Ñ∞ ‚ü©} -> {f : a ‚ü∂ b} {g : b ‚ü∂ c} -> map-S (f ‚óÜ g) ‚àº map-S f ‚óÜ map-S g
    functoriality-‚óÜ-S {a , a‚É®} {b , b‚É®} {c , c‚É®} {f , f‚É®} {g , g‚É®} = refl , lem-1
      where
        lem-1 : (‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ (f‚É® ‚óÜ g‚É®) ‚óÜ ‚ü® ‚ü® T ‚áÇ (f ‚óÜ g) ‚ü© ‚ü© c‚É®
                ‚àº
                ((‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ f‚É® ‚óÜ ‚ü® ‚ü® T ‚áÇ f ‚ü© ‚ü© b‚É®) ‚óÜ ((‚Ü≥ ‚ü® T ‚ü© b) ‚áÇ g‚É® ‚óÜ ‚ü® ‚ü® T ‚áÇ g ‚ü© ‚ü© c‚É®)
        lem-1 = {!!}

    instance
      isFunctor:S : isFunctor ‚Ñ∞ ‚Ñ∞ S
      isFunctor.map isFunctor:S = map-S
      isFunctor.isSetoidHom:map isFunctor:S = isSetoidHom:map-S
      isFunctor.functoriality-id isFunctor:S = functoriality-id-S
      isFunctor.functoriality-‚óÜ isFunctor:S = {!!}


    open ShortMonadNotation

    pure-S : ‚àÄ(a) -> a ‚ü∂ S a
    pure-S (a , a‚É®) = id , ‚ü® Œ∑Of (‚ü® T ‚ü© a) ‚ü© a‚É®

    instance
      isMonad:S : isMonad S
      isMonad.pure isMonad:S = pure-S
      isMonad.join isMonad:S = {!!}
      isMonad.isNatural:pure isMonad:S = {!!}
      isMonad.isNatural:join isMonad:S = {!!}
      isMonad.unit-l-join isMonad:S = {!!}
      isMonad.unit-r-join isMonad:S = {!!}
      isMonad.assoc-join isMonad:S = {!!}

  ‚àëMnd : Monad ‚Ñ∞
  ‚àëMnd = S
-}


--------------
-- functor from discrete categories

module _ {A : ùí∞ ùëñ} where
  private
    instance
      isSetoid:A : isSetoid A
      isSetoid:A = isSetoid:byDiscrete

      isCategory:A : isCategory A
      isCategory:A = isCategory:bySetoid

  isFunctor:byDiscrete : ‚àÄ{ùíû : Category ùëó} -> {f : A -> ‚ü® ùíû ‚ü©} -> isFunctor ‚Ä≤ A ‚Ä≤ ùíû f
  isFunctor.map isFunctor:byDiscrete = Œª {refl-‚â£ ‚Üí id}
  isFunctor.isSetoidHom:map isFunctor:byDiscrete = record { cong-‚àº = Œª {refl-‚â£ ‚Üí refl }}
  isFunctor.functoriality-id isFunctor:byDiscrete = refl
  isFunctor.functoriality-‚óÜ isFunctor:byDiscrete {f = refl-‚â£} {g = refl-‚â£} = unit-2-‚óÜ ‚Åª¬π




--------------
-- the infer object for BaseExpr
--
-- large monad

BaseExprF·µò : BaseExprData -> ùêåùêßùêù (ùêîùêßùê¢ùêØ ‚Ñì‚ÇÄ)
BaseExprF·µò ùí´ = BaseExpr ùí´

macro BaseExprF = #structureOn BaseExprF·µò

instance
  isFunctor:BaseExprF : isFunctor ‚Ä≤ BaseExprData ‚Ä≤ (ùêåùêßùêù (ùêîùêßùê¢ùêØ ‚Ñì‚ÇÄ)) BaseExprF
  isFunctor:BaseExprF = isFunctor:byDiscrete

-- BaseExprMnd = ‚àëMnd BaseExprF

BaseExprInfer : BaseExprData -> ùêàùêßùêüùêûùê´ _
BaseExprInfer d = incl (_ , BaseExpr d)

hasTextInfer:BaseExpr : (d : BaseExprData) -> hasTextInfer (BaseExprInfer d)
hasTextInfer:BaseExpr d = record
  { RepObj = ‚ä§-ùí∞
  ; TIObj = String
  ; RepType = (BaseExpr·µò d String) since isSetoid:byDiscrete
  ; rep = rep'
  ; parse = parseBaseExpr
  ; IShow:TI = record { show = show }
  }
  where
    rep' : Hom' ‚Ä≤ (‚ä§-ùí∞ ‚Üí BaseExpr·µò d Text) ‚Ä≤ (BaseExpr·µò d Text since isSetoid:byDiscrete) :& isIso
    rep' = f since P
      where
        f : ‚Ä≤ (‚ä§-ùí∞ ‚Üí BaseExpr·µò d Text) ‚Ä≤ ‚ü∂ (BaseExpr·µò d Text since isSetoid:byDiscrete)
        f = (Œª x ‚Üí x tt) since record { cong-‚àº = Œª {x ‚Üí ‚â°‚Üí‚â°-Str Œª i ‚Üí x i tt} }

        g : (BaseExpr·µò d Text since isSetoid:byDiscrete) ‚ü∂ ‚Ä≤ (‚ä§-ùí∞ ‚Üí BaseExpr·µò d Text) ‚Ä≤
        g = (Œª x x‚ÇÅ ‚Üí x) since record { cong-‚àº = Œª {refl-‚â£ ‚Üí refl-‚â°} }

        P = record { inverse-‚óÜ = g ; inv-r-‚óÜ = {!!} ; inv-l-‚óÜ = {!!} }

-- hasTextInfer:BaseExprMnd : BaseExprData -> hasTextInfer (BaseExprInfer)
-- hasTextInfer:BaseExprMnd p = record
--   { RepObj = p , ‚ä§-ùí∞
--   ; TIObj = p , String
--   ; RepType = Lift (BaseExpr·µò p String) since isSetoid:byDiscrete
--   ; rep = rep'
--   ; parse = Œª x ‚Üí mapRight lift (parseBaseExpr x)
--   ; IShow:TI = record { show = Œª x ‚Üí show (lower x) }
--   }
--   where
--     -- rep' : Hom' ‚Ä≤ Œ£ (StrId p p) (Œª a ‚Üí ‚ä§-ùí∞ ‚Üí BaseExpr·µò p ‚ä§-ùí∞) ‚Ä≤
--     --        (Lift (BaseExpr·µò p ‚ä§-ùí∞) since isSetoid:byDiscrete)
--     --        :& isIso
--     rep' : (isCategory.Hom (_:&_.of fst ‚ü® BaseExprInfer ‚ü©) (p , ‚ä§-ùí∞)
--             (‚ü® snd ‚ü® BaseExprInfer ‚ü© ‚ü© (p , String)) since it)
--             ‚âÖ (Lift (BaseExpr·µò p String) since isSetoid:byDiscrete)
--     rep' = f since P
--       where
--         f : (isCategory.Hom (_:&_.of fst ‚ü® BaseExprInfer ‚ü©) (p , ‚ä§-ùí∞)
--                     (‚ü® snd ‚ü® BaseExprInfer ‚ü© ‚ü© (p , String)) since it)

--                     ‚ü∂ (Lift (BaseExpr·µò p String) since isSetoid:byDiscrete)
--         f = (Œª (_ , x) ‚Üí ‚Ü• (x tt)) since {!!}

--         g : (Lift (BaseExpr·µò p String) since isSetoid:byDiscrete)
--             ‚ü∂
--             (isCategory.Hom (_:&_.of fst ‚ü® BaseExprInfer ‚ü©) (p , ‚ä§-ùí∞)
--                     (‚ü® snd ‚ü® BaseExprInfer ‚ü© ‚ü© (p , String)) since it)

--         g = (Œª x ‚Üí refl , (Œª x‚ÇÅ ‚Üí lower x)) since {!!}

--         P = record { inverse-‚óÜ = g ; inv-r-‚óÜ = {!!} ; inv-l-‚óÜ = {!!} }



{-
    S·µò : ‚ü® ‚Ñ∞ ‚ü© -> ‚ü® ‚Ñ∞ ‚ü©
    S·µò (a , a‚É®) = a , (‚ü® ‚ü® T ‚ü© a ‚ü© a‚É®)

    macro S = #structureOn S·µò

    map-S : ‚àÄ{a b} -> a ‚ü∂ b -> S a ‚ü∂ S b
    map-S {a , a‚É®} {b , b‚É®} (f , f‚É®) = f , g‚É®
      where
        -- g : base (S a) ‚ü∂ base (S b)
        -- g = f

        g‚É® : ‚ü® ‚ü® T ‚ü© a ‚ü© a‚É® ‚ü∂ ‚ü® ‚ü® T ‚ü© b ‚ü© b‚É®
        g‚É® = ((‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ f‚É®) ‚óÜ ‚ü® ‚ü® T ‚áÇ f ‚ü© ‚ü© b‚É®

    instance
      isSetoidHom:map-S : ‚àÄ{a} {b} -> isSetoidHom (a ‚ü∂ b) (S a ‚ü∂ S b) (map-S)
      isSetoidHom.cong-‚àº (isSetoidHom:map-S {a , a‚É®} {b , b‚É®}) {f , f‚É®} {g , g‚É®} (p , p‚É®) = p , q
        where
          p' : f‚É® ‚àº g‚É®
          p' = unit-r-‚óÜ ‚Åª¬π ‚àô p‚É®

          q : ((‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ f‚É® ‚óÜ ‚ü® ‚ü® T ‚áÇ f ‚ü© ‚ü© b‚É®) ‚óÜ id
              ‚àº
              (‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ g‚É® ‚óÜ ‚ü® ‚ü® T ‚áÇ g ‚ü© ‚ü© b‚É®
          q = unit-r-‚óÜ ‚àô ((‚Ü≥ ‚ü® T ‚ü© a) ‚áÇ‚âÄ p') ‚óà ‚ü® ‚ü® T ‚áÇ‚âÄ p ‚ü© ‚ü© b‚É®

    functoriality-id-S : ‚àÄ{a} -> map-S (idOn a) ‚àº idOn (S a)
    functoriality-id-S {a , a‚É®} = refl , ((functoriality-id {{of ‚Ü≥ ‚ü® T ‚ü© a}} ‚óà ‚ü® ‚ü® functoriality-id ‚ü© ‚ü© a‚É® ‚àô unit-2-‚óÜ) ‚óà refl ‚àô unit-r-‚óÜ)

    functoriality-‚óÜ-S : ‚àÄ{a b c : ‚ü® ‚Ñ∞ ‚ü©} -> {f : a ‚ü∂ b} {g : b ‚ü∂ c} -> map-S (f ‚óÜ g) ‚àº map-S f ‚óÜ map-S g
    functoriality-‚óÜ-S {a , a‚É®} {b , b‚É®} {c , c‚É®} {f , f‚É®} {g , g‚É®} = refl , (({!?!} ‚àô assoc-l-‚óÜ) ‚óà refl ‚àô unit-r-‚óÜ)


    instance
      isFunctor:S : isFunctor ‚Ñ∞ ‚Ñ∞ S
      isFunctor.map isFunctor:S = map-S
      isFunctor.isSetoidHom:map isFunctor:S = isSetoidHom:map-S
      isFunctor.functoriality-id isFunctor:S = functoriality-id-S
      isFunctor.functoriality-‚óÜ isFunctor:S = {!!}

-}
    -- open ShortMonadNotation

    -- pure-S : ‚àÄ(a) -> a ‚ü∂ S a
    -- pure-S (a , a‚É®) = id , ‚ü® Œ∑Of (‚ü® T ‚ü© a) ‚ü© a‚É®

    -- instance

    --   isMonad:S : isMonad S
    --   isMonad.pure isMonad:S = pure-S
    --   isMonad.join isMonad:S = {!!}
    --   isMonad.isNatural:pure isMonad:S = {!!}
    --   isMonad.isNatural:join isMonad:S = {!!}
    --   isMonad.unit-l-join isMonad:S = {!!}
    --   isMonad.unit-r-join isMonad:S = {!!}
    --   isMonad.assoc-join isMonad:S = {!!}

    -- aaaaa = isFunctor:const

    -- ùíü : Category _
    -- ùíü = {!!}



-- Â§ßùêåùêßùêù>BaseExpr : Â§ßùêåùêßùêù _
-- Â§ßùêåùêßùêù>BaseExpr = {!!} , {!!}


-}
